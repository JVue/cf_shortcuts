#!/bin/bash
#
# Author: Jeffrey Cutter
# License: GPL v3
#
# Note: This program can enable you to do things faster, including mistakes, use at your own risk.
#

TAIL_NUMBER=3
ALL_TAIL_NUMBER=999999999999999
NAME=$(basename $0)
DIR=$(dirname $0)
cfhosts_cmd="$DIR/cfhosts.rb"
cfhosts_file="$DIR/cfhosts"
USER="root"

groups=$($cfhosts_cmd $cfhosts_file list_groups)

function usage_common {
  echo "DESCRIPTION: $2"
  echo
  echo "USAGE: $NAME [-s] $1"
  echo
  shift 2
  if [ $# -ne 0 ]
  then
    echo "DETAILS:"
    for i in "$@"
    do
      if [ -n "$i" ]
      then
        echo "$i"
      fi
    done
    echo
  fi
  echo "  -s to run serially"
  echo
}

function usage_case {
  echo
  echo "  -i is optional to ignore case with grep"
}

function usage_log_file {
  echo
  echo "  log_file is optional and defaults to automation.log"
  echo "    For CloudForms logs, log_file can be in the format of evm or evm.log"
  echo "    For any other files, use /the/full/path/to/file"
}

function usage_pattern {
  echo
  echo "  pattern may be specified as a regex suitable for egrep taking care to prevent the shell from interpretation"
  if [[ $NAME != 'cfgrep-request' || $NAME != 'cftail-request' ]]
  then
    echo "  pattern may be specified as 'nogrep' to have no grep or use cat instead of grep"
  fi
}

function usage_commas {
  echo
  echo "  commas in request_id will automatically be stripped"
}

function usage_tail {
  echo
  echo "  -l can be used to place output in separate window panes, by default output is merged"
  echo
  echo "  In multitail:"
  echo "    Move around the buffer similar to less by pressing 'b'"
  echo "    Exit whatever context you are in by pressing 'q'"
}

function usage_grep {
  echo
  echo "  -a can be used to also grep archived logs"
}

function usage_output {
  if [[ $NAME == 'cfgrep-collate' || $NAME == 'cfgrep-request' ]]
  then
    echo
    echo "  -o outputfile can be used to save output to outputfile"
  fi
}

function usage_help {
  echo "  -h | --help for this usage statement"
  echo
}

function usage_regex {
  USAGE=$1
  DESCRIPTION=$2
  shift 2
  usage_common "$USAGE" "$DESCRIPTION" "$(eval usage_case)" "$(eval usage_pattern)" "$(eval usage_output)" "$(eval usage_log_file)" "$@"
}


function usage_request {
  USAGE=$1
  DESCRIPTION=$2
  shift 2
  usage_common "$USAGE" "$DESCRIPTION" "$(eval usage_commas)" "$(eval usage_output)" "$(eval usage_log_file)" "$@"
}

function usage {
  echo
  case $NAME in
    "cfssh") usage_common "[-g group] command args" "ssh and run command with args" ;;
    "cfscp") usage_common "[-g group] local_file remote_dest_dir" "push files out using scp" " " "  Only one file is supported at a time" ;;
    "cfcollect") usage_common "[-g group] remote_file local_dest_dir" "pull files in using scp" " " "  Wildcards are accepted for remote_file but should only match one file" " " "  local_files are appended with remote hostname" ;;
    "cfgrep") usage_regex "[-a] [-c count] [-i] [-g group] pattern [log_file]" "grep log_file for pattern and show last count number of lines" " " "  -c count is optional and used with tail to limit the output, default is $TAIL_NUMBER" "  To show all lines specify -c all" "$(eval usage_grep)" ;;
    "cfgrep-collate") usage_regex "[-a] [-i] [-o outputfile] [-g group] pattern [log_file]" "grep log_file for pattern and collate all results and display using less" "$(eval usage_grep)" ;;
    "cfgrep-request") usage_request "[-a] [-o outputfile] [-g group] request_id [log_file]" "grep log_file for request_id and all its associated tasks and collate all results and display with less" "$(eval usage_grep)" ;;
    "cftail") usage_regex "[-i] [-l] [-g group] pattern [log_file]" "multitail and optionally grep pattern" "$(eval usage_tail)" ;;
    "cftail-request") usage_request "[-l] [-g group] request_id [log_file]" "multitail and grep request_id and all its associated tasks" "$(eval usage_tail)" ;;
  esac
  echo "AVAILABLE GROUPS (default is all):"
  echo
  for i in $groups
  do
    echo "  $i"
  done
  echo
  echo "To see matching hosts for a given group, use:"
  echo
  echo "$NAME [-q] -g <group> list"
  echo "  -q to suppress header"
  echo
  exit 1
}

function clean_tmp_files {
  rm -f $TMPFILE
  clean_pssh_out
}

function clean_pssh_out {
  if [ "$USE_PSSH" == 'true' ]
  then
    rm -rf $PSSH_OUTDIR
  fi
}

GREP="zgrep -e"
L='L'

SAVEOUT=false
SERIAL=false

while getopts ac:g:hilqo:s OPT
do
  case $OPT in
    a) GREP_ARCHIVED=true ;;
    c) TAIL_NUMBER=$OPTARG ;;
    g) group=$OPTARG ;;
    i) GREP="$GREP -i" ;;
    l) L='l' ;;
    q) QUIET=true ;;
    o) SAVEOUT=true
       TMPFILE=$OPTARG
      ;;
    s) SERIAL=true ;;
    *) usage ;;
  esac
done

shift $((OPTIND-1))


if [ "$SERIAL" != 'true' ]
then
  which pssh > /dev/null 2>&1
  if [ $? -eq 0 ]
  then
    USE_PSSH=true
  else
    USE_PSSH=false
  fi
fi

if [ "$USE_PSSH" == 'true' ]
then
  PSSH_OUTDIR="/tmp/.$NAME.pssh.$$"
  if [ -e "$PSSH_OUTDIR" ]
  then
    echo
    read -p "PSSH_OUTDIR $PSSH_OUTDIR already exists!  Remove? (Y/N) " answer
    answer=$(echo $answer | cut -c1 | tr [A-Z] [a-z])
    if [ "$answer" == 'y' ]
    then
      rm -rf $PSSH_OUTDIR
      if [ $? -ne 0 ]
      then
        echo "Unable to remove $PSSH_OUTDIR!"
        exit 1
      fi
    else
      exit 1
    fi
  fi
fi

if [[ $NAME == 'cfgrep-collate' || $NAME == 'cfgrep-request' ]]
then
  if [ -z "$TMPFILE" ]
  then
    TMPFILE="/tmp/.$NAME.$$"
  fi

  if [ -e "$TMPFILE" ]
  then
    echo
    read -p "TMPFILE $TMPFILE already exists!  Erase? (Y/N) " answer
    answer=$(echo $answer | cut -c1 | tr [A-Z] [a-z])
    if [ "$answer" == 'y' ]
    then
      > $TMPFILE
      if [ $? -ne 0 ]
      then
        echo "Unable to erase $TMPFILE!"
        exit 1
      fi
    else
      exit 1
    fi
  fi
fi

if [[ $NAME != 'cfgrep-collate' && $NAME != 'cfgrep-request' && "$SAVEOUT" == 'true' ]]
then
  echo
  echo "$NAME does not support -o option."
  usage
fi

if [ "$SAVEOUT" == 'false' ]
then
  trap clean_tmp_files EXIT
else
  trap clean_pssh_out EXIT
fi

if [ $NAME == 'cfssh' ]
then
  if [ $# -lt 1 ]
  then
    echo
    echo "Not enough arguments!"
    usage
  fi
elif [[ "$2" == "list" && $# -lt 2 ]]
then
  echo
  echo "Not enough arguments!"
  usage
elif [[ $NAME == 'cfgrep' || $NAME == 'cfgrep-collate' || $NAME == "cfgrep-request" || $NAME == "cftail" || $NAME == "cftail-request" ]]
then
  if [[ $# -ne 1 && $# -ne 2 ]]
  then
    echo
    echo "Wrong number of arguments!"
    usage
  fi
else
  if [ $# -ne 2 ]
  then
    echo
    echo "Wrong number of arguments!"
    usage
  fi
fi

if [ -z "$group" ]
then
  group=all
fi

if [ ! -r "$cfhosts_file" ]
then
  echo
  echo "$cfhosts_file not available!"
  usage
fi

if [ ! -x "$cfhosts_cmd" ]
then
  echo
  echo "$cfhosts_file not executable!"
  usage
fi

if [[ $NAME == 'cfgrep-request' || $NAME == 'cftail-request' ]]
then
  if [ ! -d '/var/www/miq/vmdb' ]
  then
    echo
    echo "ERROR: $NAME must be run from a CloudForms appliance!"
    echo
    exit 1
  fi
fi

if [[ $NAME == 'cftail' || $NAME == 'cftail-request' ]]
then
  which multitail > /dev/null 2>&1
  if [ $? -ne 0 ]
  then
    echo
    echo "ERROR: $NAME requires multitail be installed an in PATH!"
    echo
    exit 1
  fi
fi

# Check that we have a ruby available for cfhosts_cmd to use
/usr/bin/env ruby --version > /dev/null 2>&1
if [ $? -ne 0 ]
then
  echo
  echo "Unable to find ruby with /usr/bin/env ruby.  Please make sure ruby is installed."
  echo
  exit 1
fi

/usr/bin/env perl -v > /dev/null 2>&1
if [ $? -ne 0 ]
then
  echo
  echo "Unable to find perl with /usr/bin/env perl.  Please make sure perl is installed."
  echo
  exit 1
fi

group_good=false

for i in $groups
do
  if [ "$i" == "$group" ]
  then
    group_good=true
  fi
done

if [ "$group_good" != "true" ]
then
  echo
  echo "Group $group not found in $cfhosts_file"
  usage
fi

if [[ "$QUIET" != 'true' && "$USE_PSSH" != 'true' || $NAME == 'cfgrep-request' ]]
then
  echo
fi

SERVERS=$($cfhosts_cmd $cfhosts_file list_servers $group)

if [ "$1" == "list" ]
then
  if [ "$QUIET" != 'true' ]
  then
    echo "Matching servers:"
  fi
  for i in $SERVERS
  do
    echo $i
  done
  exit
fi

if [[ $NAME == 'cfgrep' || $NAME == 'cfgrep-collate' || $NAME == 'cfgrep-request' || $NAME == 'cftail' || $NAME == 'cftail-request' ]]
then
  PATTERN="$1"
  if [ "$PATTERN" == 'nogrep' ]
  then
    if [[ $NAME == 'cfgrep' || $NAME == 'cfgrep-collate' ]]
    then
      GREP='cat'
    PATTERN=''
    fi
  fi
  if [[ $NAME == 'cfgrep-request' || $NAME == 'cftail-request' ]]
  then
    REQUEST_ID=$(echo $PATTERN | sed 's/,//g')
    echo "*** looking for tasks associated with request_id: $REQUEST_ID ***"
    cd /var/www/miq/vmdb
    TASK_IDS=$(echo "select id from miq_request_tasks where miq_request_id = $REQUEST_ID" | rails db | awk '$1!="id" && !/^---/ && !/^\(/ {print $1}' | sort -n)
    echo
    TASK_IDS=$(echo $TASK_IDS)
    cd - > /dev/null
    PATTERN="$REQUEST_ID|$(echo $TASK_IDS | sed 's/ /|/g')"
    echo "*** looking for request_id: $REQUEST_ID and task_ids: $TASK_IDS ***"
    echo
    if [ $NAME == 'cftail-request' ]
    then
      sleep 1
    fi
  fi
  PATTERN=$(echo $PATTERN | sed -e 's/|/\\|/g')
  LOG=$2
  if [ -z "$LOG" ]
  then
    LOG='automation.log'
  fi
  if [ "$(echo $LOG | cut -c1)" != "/" ]
  then
    LOG="/var/www/miq/vmdb/log/$(echo $LOG | sed 's/\.log$//').log"
  fi
  if [[ $NAME == 'cfgrep' || $NAME == 'cfgrep-collate' || $NAME == 'cfgrep-request' ]]
  then
    if [ "$GREP_ARCHIVED" == 'true' ]
    then
      LOG="$LOG-* $LOG"
    fi
  fi
  if [[ $NAME == 'cfgrep' ]]
  then
    if [ "$TAIL_NUMBER" == 'all' ]
    then
      TAIL_NUMBER=$ALL_TAIL_NUMBER
    fi
    TAIL="tail -$TAIL_NUMBER"
  else
    TAIL="tail"
  fi
fi

ARGS=$*
ARGS=$(echo $ARGS | sed 's/*/\\*/g')

if [[ $NAME != 'cftail' && $NAME != 'cftail-request' ]]
then

  if [ "$USE_PSSH" != 'true' ]
  then
  
    for i in $SERVERS
    do
      echo "*** $i ***"
      case $NAME in
        "cfssh") ssh $USER@$i $ARGS ;;
        "cfscp") scp $1 $USER@$i:$2 ;;
        "cfcollect") scp $USER@$i:$1 $2/$(basename $1)-$i ;;
        "cfgrep") ssh $USER@$i "$GREP \"$PATTERN\" $LOG | $TAIL" | perl -pe 's/^\/.*?://' ;;
        "cfgrep-collate"|"cfgrep-request") ssh $USER@$i "$GREP \"$PATTERN\" $LOG" | perl -pe 's/^\/.*?://' | sed -e "s/^/[$i] /" >> $TMPFILE ;;
      esac
      echo
    done

  else

    HOSTS=""
    for i in $SERVERS
    do
      HOSTS="$HOSTS -H $USER@$i"
    done

    case $NAME in
        "cfssh") pssh -i $HOSTS $ARGS ;;
        "cfscp") pscp.pssh $HOSTS $1 $2 ;;
        "cfcollect") pslurp $HOSTS -L $2 $1 $2 ;;
        "cfgrep") pssh -i $HOSTS -o $PSSH_OUTDIR "$GREP \"$PATTERN\" $LOG | $TAIL | perl -pe 's/^\/.*?://'" ;;
        "cfgrep-collate"|"cfgrep-request") pssh $HOSTS -o $PSSH_OUTDIR "$GREP \"$PATTERN\" $LOG | perl -pe 's/^\/.*?://' | sed -e \"s/^/[\$(hostname -s)] /\"" ;;
    esac
  fi

  if [[ $NAME == 'cfgrep-collate' || $NAME == 'cfgrep-request' ]]
  then
    echo "*** collating results ***"
    if [ "$USE_PSSH" == 'true' ]
    then
      cat $PSSH_OUTDIR/* > $TMPFILE
    fi
    sort -k 4 $TMPFILE > $TMPFILE.sort
    mv $TMPFILE.sort $TMPFILE
    less $TMPFILE
    echo
  fi

else

  COMMAND='multitail'
  if [ $NAME == 'cftail-request' ]
  then
    TAIL='tail -n $ALL_TAIL_NUMBER -f'
  else
    TAIL='tail -f'
  fi
  if [ "$PATTERN" == 'nogrep' ]
  then
    CLIENT_CMD="$TAIL $LOG"
  else
    CLIENT_CMD="$TAIL $LOG \| $GREP \\\"$PATTERN\\\""
  fi

  for i in $SERVERS
  do
    COMMAND="$COMMAND -$L \"ssh $i $CLIENT_CMD | sed -e 's/^/[$i] /'\""
  done

  echo "Running: $COMMAND"

  eval $COMMAND

fi

if [ "$SAVEOUT" == 'true' ]
then
  echo "Output File: $TMPFILE"
fi
